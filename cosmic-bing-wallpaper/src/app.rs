//! # COSMIC Application Module
//!
//! Implements the main application using the libcosmic toolkit, following the
//! Model-View-Update (MVU) architecture pattern.
//!
//! ## Architecture Overview
//!
//! The MVU pattern separates the application into three distinct parts:
//!
//! - **Model** (`BingWallpaper` struct): Holds all application state including
//!   configuration, current image, UI state, and timer status.
//!
//! - **View** (`view_main`, `view_history`): Pure functions that render the UI
//!   based on the current model state. Views are rebuilt whenever state changes.
//!
//! - **Update** (`update` method): Handles incoming messages, updates the model,
//!   and returns commands (async tasks) to be executed.
//!
//! ## Message Flow
//!
//! 1. User interacts with UI (e.g., clicks "Fetch Today's Image")
//! 2. UI generates a `Message` (e.g., `Message::FetchToday`)
//! 3. `update()` handles the message, updates state, returns async Task
//! 4. Task executes (API call, file download, etc.)
//! 5. Task completion generates another Message with the result
//! 6. `update()` handles the result message, updates state
//! 7. View re-renders with new state
//!
//! ## COSMIC Desktop Integration
//!
//! This app integrates with COSMIC by:
//! - Writing wallpaper config to `~/.config/cosmic/com.system76.CosmicBackground/v1/all`
//! - Using RON (Rusty Object Notation) format expected by cosmic-bg
//! - Restarting cosmic-bg process to apply changes
//! - Managing automatic updates via internal timer (D-Bus)

use chrono;
use cosmic::app::Core;
use cosmic::iced::{Length, ContentFit};
use cosmic::widget::{self, button, column, container, row, text, dropdown, scrollable, settings, toggler};
use cosmic::{Action, Application, Element, Task};
use std::path::PathBuf;

use crate::bing::{BingImage, fetch_bing_image_info, download_image};
use crate::config::{Config, MARKETS};
use crate::dbus_client::WallpaperClient;
use crate::service::is_flatpak;

/// Unique application identifier for COSMIC.
/// Used for window identification and desktop integration.
pub const APP_ID: &str = "io.github.reality2_roycdavies.cosmic-bing-wallpaper";

/// Main application state struct.
///
/// Contains all mutable state for the application including configuration,
/// UI state, and cached data. This is the "Model" in MVU architecture.
pub struct BingWallpaper {
    /// COSMIC core state (window management, theming, etc.)
    core: Core,
    /// User configuration (market, wallpaper directory, etc.)
    config: Config,
    /// Metadata for the currently fetched Bing image
    current_image: Option<BingImage>,
    /// Local filesystem path to the downloaded image
    image_path: Option<String>,
    /// Status message displayed to the user (e.g., "Downloading...", "Error: ...")
    status_message: String,
    /// True when an async operation is in progress (disables buttons)
    is_loading: bool,
    /// List of previously downloaded wallpapers
    history: Vec<HistoryItem>,
    /// Index of selected market in the dropdown (maps to MARKETS array)
    selected_market_idx: usize,
    /// Current view (Main or History)
    view_mode: ViewMode,
    /// Pre-computed market names for dropdown (avoids lifetime issues in view)
    market_names: Vec<String>,
    /// Current status of the auto-update timer
    timer_status: TimerStatus,
    /// Path of wallpaper pending deletion (for confirmation)
    pending_delete: Option<PathBuf>,
}

/// Represents a wallpaper in the download history.
///
/// Created by scanning the wallpaper directory for image files.
#[derive(Debug, Clone)]
pub struct HistoryItem {
    /// Full filesystem path to the image
    pub path: PathBuf,
    /// Filename only (e.g., "bing-2026-01-15.jpg")
    pub filename: String,
    /// Extracted date from filename for display (e.g., "2026-01-15")
    pub date: String,
}

/// Enum representing the current view/screen of the application.
#[derive(Debug, Clone, Default, PartialEq)]
pub enum ViewMode {
    /// Main view showing today's image and controls
    #[default]
    Main,
    /// History browser showing all downloaded wallpapers
    History,
}

/// Status of the auto-update timer.
///
/// Checked asynchronously on app startup and after enable/disable operations.
#[derive(Debug, Clone, Default)]
pub enum TimerStatus {
    /// Timer status is being queried
    #[default]
    Checking,
    /// Timer is not installed (user can install it)
    NotInstalled,
    /// Timer is active with the next scheduled run time
    Installed {
        /// Human-readable next run time
        next_run: String
    },
    /// Error occurred while checking timer status
    Error(String),
}

/// All possible messages/events the application can receive.
///
/// Messages are the "Update" triggers in MVU architecture. They can be
/// generated by user interaction, async task completion, or system events.
#[derive(Debug, Clone)]
pub enum Message {
    // === Image Fetching ===
    /// User clicked "Fetch Today's Image" - starts the fetch chain
    FetchToday,
    /// API call completed - contains image metadata or error
    FetchedImageInfo(Result<BingImage, String>),
    /// Image download completed - contains file path or error
    DownloadedImage(Result<String, String>),

    // === Wallpaper Application ===
    /// User clicked "Apply" on a history item
    ApplyHistoryWallpaper(PathBuf),
    /// Wallpaper application completed
    AppliedWallpaper(Result<(), String>),

    // === UI Navigation ===
    /// User selected a different market from dropdown
    MarketSelected(usize),
    /// Switch to history view
    ShowHistory,
    /// Switch back to main view
    ShowMain,
    /// Rescan wallpaper directory for history items
    RefreshHistory,
    /// Request to delete a wallpaper (shows confirmation)
    RequestDeleteHistoryItem(PathBuf),
    /// Confirm deletion of pending wallpaper
    ConfirmDeleteHistoryItem,
    /// Cancel pending deletion
    CancelDeleteHistoryItem,

    // === Timer Management ===
    /// Query timer status via D-Bus
    CheckTimerStatus,
    /// Timer status query completed
    TimerStatusChecked(TimerStatus),
    /// User clicked "Install Auto-Update Timer"
    InstallTimer,
    /// Timer installation completed
    TimerInstalled(Result<(), String>),
    /// User clicked "Remove Timer"
    UninstallTimer,
    /// Timer removal completed
    TimerUninstalled(Result<(), String>),

    // === State Sync ===
    /// Sync current wallpaper state from D-Bus service (if tray already fetched)
    SyncCurrentWallpaper,
    /// Current wallpaper state received from service
    CurrentWallpaperSynced(Option<String>),
}

/// Implementation of the COSMIC Application trait.
///
/// This is where the MVU architecture connects to the COSMIC framework.
/// The trait requires defining the executor, flags, message type, and
/// implementing core(), core_mut(), init(), view(), and update().
impl Application for BingWallpaper {
    /// Async executor for running Tasks (uses tokio under the hood)
    type Executor = cosmic::executor::Default;
    /// Initialization flags (unused, unit type)
    type Flags = ();
    /// Message type for the application
    type Message = Message;

    /// Application identifier for COSMIC
    const APP_ID: &'static str = APP_ID;

    fn core(&self) -> &Core {
        &self.core
    }

    fn core_mut(&mut self) -> &mut Core {
        &mut self.core
    }

    /// Initializes the application state and triggers startup tasks.
    ///
    /// Called once when the application starts. Sets up:
    /// - Configuration loaded from disk (or defaults)
    /// - Empty image state
    /// - Wallpaper history scanned from disk
    /// - Market dropdown options
    ///
    /// Automatically triggers two startup actions:
    /// 1. Fetch today's Bing image
    /// 2. Check timer status via D-Bus
    fn init(core: Core, _flags: Self::Flags) -> (Self, Task<Action<Self::Message>>) {
        let config = Config::load();

        // Find the index of the configured market in MARKETS array
        let selected_market_idx = MARKETS
            .iter()
            .position(|m| m.code == config.market)
            .unwrap_or(0);

        // Scan for existing wallpapers
        let history = scan_history(&config.wallpaper_dir);

        // Pre-compute market names to avoid lifetime issues in view()
        let market_names: Vec<String> = MARKETS.iter().map(|m| m.name.to_string()).collect();

        let app = Self {
            core,
            config,
            current_image: None,
            image_path: None,
            status_message: "Ready".to_string(),
            is_loading: false,
            history,
            selected_market_idx,
            view_mode: ViewMode::Main,
            market_names,
            timer_status: TimerStatus::Checking,
            pending_delete: None,
        };

        // Trigger startup actions: check timer status, sync current wallpaper from tray, and optionally fetch
        let timer_task = Task::perform(async {}, |_| Action::App(Message::CheckTimerStatus));
        let sync_task = Task::perform(async {}, |_| Action::App(Message::SyncCurrentWallpaper));

        let timer_enabled = crate::timer::TimerState::load().enabled;
        if timer_enabled && app.config.fetch_on_startup {
            let fetch_task = Task::perform(async {}, |_| Action::App(Message::FetchToday));
            (app, Task::batch([sync_task, fetch_task, timer_task]))
        } else {
            (app, Task::batch([sync_task, timer_task]))
        }
    }

    fn header_start(&self) -> Vec<Element<'_, Self::Message>> {
        vec![]
    }

    /// Renders the UI based on current state.
    ///
    /// Delegates to `view_main()` or `view_history()` based on the current
    /// `view_mode`. This is the "View" in MVU architecture.
    fn view(&self) -> Element<'_, Self::Message> {
        match self.view_mode {
            ViewMode::Main => self.view_main(),
            ViewMode::History => self.view_history(),
        }
    }

    /// Background subscription that periodically checks timer status.
    ///
    /// This allows the app to reflect changes made externally (e.g., from the
    /// system tray or command line) without requiring manual refresh.
    fn subscription(&self) -> cosmic::iced::Subscription<Self::Message> {
        cosmic::iced::time::every(std::time::Duration::from_secs(5))
            .map(|_| Message::CheckTimerStatus)
    }

    /// Handles incoming messages and returns tasks to execute.
    ///
    /// This is the "Update" in MVU architecture. Each message type has a
    /// corresponding handler that updates state and optionally returns
    /// async tasks for operations like API calls or file I/O.
    fn update(&mut self, message: Self::Message) -> Task<Action<Self::Message>> {
        match message {
            Message::FetchToday => {
                self.status_message = "Fetching image info...".to_string();
                self.is_loading = true;
                let market = self.config.market.clone();

                Task::perform(
                    async move { fetch_bing_image_info(&market).await },
                    |result| Action::App(Message::FetchedImageInfo(result)),
                )
            }

            Message::FetchedImageInfo(result) => {
                match result {
                    Ok(image) => {
                        self.current_image = Some(image.clone());
                        self.status_message = "Downloading image...".to_string();
                        let dir = self.config.wallpaper_dir.clone();
                        let market = self.config.market.clone();

                        Task::perform(
                            async move { download_image(&image, &dir, &market).await },
                            |result| Action::App(Message::DownloadedImage(result)),
                        )
                    }
                    Err(e) => {
                        self.status_message = format!("Error: {}", e);
                        self.is_loading = false;
                        Task::none()
                    }
                }
            }

            Message::DownloadedImage(result) => {
                match result {
                    Ok(path) => {
                        self.image_path = Some(path.clone());

                        // Clean up old wallpapers based on keep_days setting
                        let deleted = cleanup_old_wallpapers(&self.config.wallpaper_dir, self.config.keep_days);
                        if deleted > 0 {
                            self.status_message = format!(
                                "Downloaded ({} old cleaned up). Applying...",
                                deleted
                            );
                        } else {
                            self.status_message = "Downloaded. Applying wallpaper...".to_string();
                        }

                        self.history = scan_history(&self.config.wallpaper_dir);

                        // Auto-apply the wallpaper after downloading
                        Task::perform(
                            async move { apply_cosmic_wallpaper(&path).await },
                            |result| Action::App(Message::AppliedWallpaper(result)),
                        )
                    }
                    Err(e) => {
                        self.is_loading = false;
                        self.status_message = format!("Error: {}", e);
                        Task::none()
                    }
                }
            }

            Message::ApplyHistoryWallpaper(path) => {
                self.apply_wallpaper_from_path(path.to_string_lossy().to_string())
            }

            Message::AppliedWallpaper(result) => {
                self.is_loading = false;
                match result {
                    Ok(()) => {
                        self.status_message = "Wallpaper applied!".to_string();
                    }
                    Err(e) => {
                        self.status_message = format!("Error: {}", e);
                    }
                }
                Task::none()
            }

            Message::MarketSelected(idx) => {
                if idx < MARKETS.len() {
                    self.selected_market_idx = idx;
                    self.config.market = MARKETS[idx].code.to_string();
                    let _ = self.config.save();
                }
                Task::none()
            }

            Message::ShowHistory => {
                self.view_mode = ViewMode::History;
                self.status_message = String::new(); // Clear status when switching views
                self.history = scan_history(&self.config.wallpaper_dir);
                Task::none()
            }

            Message::ShowMain => {
                self.view_mode = ViewMode::Main;
                self.status_message = "Ready".to_string(); // Reset status when returning
                Task::none()
            }

            Message::RefreshHistory => {
                self.history = scan_history(&self.config.wallpaper_dir);
                Task::none()
            }

            Message::RequestDeleteHistoryItem(path) => {
                let filename = path.file_name()
                    .and_then(|s| s.to_str())
                    .unwrap_or("this image")
                    .to_string();
                self.pending_delete = Some(path);
                self.status_message = format!("Delete {}? Click 'Confirm' to delete or 'Cancel' to keep.", filename);
                Task::none()
            }

            Message::ConfirmDeleteHistoryItem => {
                if let Some(path) = self.pending_delete.take() {
                    if let Err(e) = std::fs::remove_file(&path) {
                        self.status_message = format!("Failed to delete: {}", e);
                    } else {
                        self.history = scan_history(&self.config.wallpaper_dir);
                        self.status_message = "Image deleted".to_string();
                    }
                }
                Task::none()
            }

            Message::CancelDeleteHistoryItem => {
                self.pending_delete = None;
                self.status_message = "Delete cancelled".to_string();
                Task::none()
            }

            Message::CheckTimerStatus => {
                // Refresh GUI lockfile every 30 seconds (every 6 ticks at 5-second intervals)
                static TICK_COUNT: std::sync::atomic::AtomicU32 = std::sync::atomic::AtomicU32::new(0);
                let count = TICK_COUNT.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
                if count % 6 == 0 {
                    crate::create_gui_lockfile();
                }

                Task::perform(
                    async { check_timer_status().await },
                    |status| Action::App(Message::TimerStatusChecked(status)),
                )
            }

            Message::TimerStatusChecked(status) => {
                self.timer_status = status;
                Task::none()
            }

            Message::InstallTimer => {
                self.status_message = "Enabling Daily Update...".to_string();
                Task::perform(
                    async { install_timer().await },
                    |result| Action::App(Message::TimerInstalled(result)),
                )
            }

            Message::TimerInstalled(result) => {
                match result {
                    Ok(()) => {
                        self.status_message = "Daily Update enabled!".to_string();
                    }
                    Err(e) => {
                        self.status_message = format!("Failed to enable Daily Update: {}", e);
                    }
                }
                // Refresh timer status
                Task::perform(
                    async { check_timer_status().await },
                    |status| Action::App(Message::TimerStatusChecked(status)),
                )
            }

            Message::UninstallTimer => {
                self.status_message = "Disabling Daily Update...".to_string();
                Task::perform(
                    async { uninstall_timer().await },
                    |result| Action::App(Message::TimerUninstalled(result)),
                )
            }

            Message::TimerUninstalled(result) => {
                match result {
                    Ok(()) => {
                        self.status_message = "Daily Update disabled.".to_string();
                    }
                    Err(e) => {
                        self.status_message = format!("Failed to disable Daily Update: {}", e);
                    }
                }
                Task::perform(
                    async { check_timer_status().await },
                    |status| Action::App(Message::TimerStatusChecked(status)),
                )
            }

            Message::SyncCurrentWallpaper => {
                // Query the D-Bus service for the current wallpaper (in case tray already fetched)
                Task::perform(
                    async {
                        match crate::dbus_client::WallpaperClient::connect().await {
                            Ok(client) => {
                                match client.get_current_wallpaper_path().await {
                                    Ok(path) if !path.is_empty() => Some(path),
                                    _ => None,
                                }
                            }
                            Err(_) => None,
                        }
                    },
                    |path| Action::App(Message::CurrentWallpaperSynced(path)),
                )
            }

            Message::CurrentWallpaperSynced(path) => {
                if let Some(p) = path {
                    // Only update if we don't already have an image loaded
                    if self.image_path.is_none() {
                        self.image_path = Some(p);
                    }
                }
                Task::none()
            }
        }
    }
}

impl BingWallpaper {
    fn apply_wallpaper_from_path(&mut self, path: String) -> Task<Action<Message>> {
        self.status_message = "Applying wallpaper...".to_string();
        self.is_loading = true;

        Task::perform(
            async move { apply_cosmic_wallpaper(&path).await },
            |result| Action::App(Message::AppliedWallpaper(result)),
        )
    }

    fn view_main(&self) -> Element<'_, Message> {
        // Today's Wallpaper section - image preview in a card
        let preview_content: Element<_> = if let Some(path) = &self.image_path {
            container(
                widget::image(path)
                    .content_fit(ContentFit::Contain)
                    .height(Length::Fixed(280.0))
            )
            .width(Length::Fill)
            .center_x(Length::Fill)
            .into()
        } else {
            container(text::body("Click 'Fetch Today's Wallpaper' to get started"))
                .padding(60)
                .width(Length::Fill)
                .center_x(Length::Fill)
                .into()
        };

        let image_title = self.current_image.as_ref()
            .map(|img| img.title.clone())
            .unwrap_or_else(|| "—".to_string());

        let image_copyright = self.current_image.as_ref()
            .map(|img| img.copyright.clone())
            .unwrap_or_else(|| "—".to_string());

        // Page title (large, like COSMIC Settings)
        let page_title = text::title1("Bing Daily Wallpaper");

        let wallpaper_section = settings::section()
            .title("Today's Wallpaper")
            .add(
                container(preview_content)
                    .width(Length::Fill)
                    .padding(12)
                    .class(cosmic::theme::Container::Card)
            )
            .add(
                row()
                    .spacing(16)
                    .push(text::body("Title"))
                    .push(cosmic::widget::horizontal_space())
                    .push(text::body(image_title))
            )
            .add(
                row()
                    .spacing(16)
                    .push(text::body("Copyright"))
                    .push(cosmic::widget::horizontal_space())
                    .push(text::caption(image_copyright))
            )
            .add(
                settings::item(
                    "Status",
                    text::caption(self.status_message.clone()),
                )
            );

        // Settings section
        let timer_enabled = matches!(&self.timer_status, TimerStatus::Installed { .. });
        let timer_description = match &self.timer_status {
            TimerStatus::Checking => "Checking...".to_string(),
            TimerStatus::NotInstalled => "Disabled".to_string(),
            TimerStatus::Installed { next_run } => format!("Next: {}", next_run),
            TimerStatus::Error(e) => format!("Error: {}", e),
        };

        let settings_section = settings::section()
            .title("Settings")
            .add(
                settings::item(
                    "Region",
                    dropdown(&self.market_names, Some(self.selected_market_idx), Message::MarketSelected)
                        .width(Length::Fixed(200.0)),
                )
            )
            .add(
                settings::flex_item(
                    "Daily Update",
                    row()
                        .spacing(12)
                        .align_y(cosmic::iced::Alignment::Center)
                        .push(text::caption(timer_description))
                        .push(
                            toggler(timer_enabled)
                                .on_toggle(|enabled| {
                                    if enabled {
                                        Message::InstallTimer
                                    } else {
                                        Message::UninstallTimer
                                    }
                                })
                        ),
                )
            );

        // Actions section - below settings
        let fetch_btn = button::suggested("Fetch Today's Wallpaper")
            .on_press_maybe(if self.is_loading { None } else { Some(Message::FetchToday) });

        let history_btn = button::standard("History")
            .on_press(Message::ShowHistory);

        let actions_section = settings::section()
            .title("Actions")
            .add(
                settings::item_row(vec![
                    fetch_btn.into(),
                    history_btn.into(),
                ])
            );

        // Main content using settings::view_column for proper COSMIC styling
        let content = settings::view_column(vec![
            page_title.into(),
            wallpaper_section.into(),
            settings_section.into(),
            actions_section.into(),
        ]);

        widget::scrollable(
            container(
                container(content)
                    .max_width(800)
            )
            .width(Length::Fill)
            .center_x(Length::Fill)
            .padding(16)
        )
        .width(Length::Fill)
        .height(Length::Fill)
        .into()
    }

    fn view_history(&self) -> Element<'_, Message> {
        let title_row = row()
            .spacing(12)
            .align_y(cosmic::iced::Alignment::Center)
            .push(
                button::icon(widget::icon::from_name("go-previous-symbolic"))
                    .on_press(Message::ShowMain)
            )
            .push(text::title3("Downloaded Wallpapers"))
            .push(cosmic::widget::horizontal_space())
            .push(
                button::icon(widget::icon::from_name("view-refresh-symbolic"))
                    .on_press(Message::RefreshHistory)
            );

        let history_content: Element<_> = if self.history.is_empty() {
            container(text::body("No wallpapers downloaded yet"))
                .padding(40)
                .center_x(Length::Fill)
                .into()
        } else {
            let mut history_column = column().spacing(12).padding(10);

            for item in &self.history {
                let item_path = item.path.clone();
                let delete_path = item.path.clone();

                let preview = widget::image(item.path.to_string_lossy().to_string())
                    .content_fit(ContentFit::Cover)
                    .width(Length::Fixed(160.0))
                    .height(Length::Fixed(90.0));

                let info = column()
                    .spacing(4)
                    .push(text::body(item.date.clone()))
                    .push(text::caption(item.filename.clone()));

                let apply_btn = button::suggested("Apply")
                    .on_press(Message::ApplyHistoryWallpaper(item_path));

                // Show confirm/cancel if this item is pending deletion, otherwise show delete button
                let is_pending = self.pending_delete.as_ref() == Some(&item.path);
                let delete_btn: Element<_> = if is_pending {
                    row()
                        .spacing(8)
                        .push(button::destructive("Confirm").on_press(Message::ConfirmDeleteHistoryItem))
                        .push(button::standard("Cancel").on_press(Message::CancelDeleteHistoryItem))
                        .into()
                } else {
                    button::destructive("Delete")
                        .on_press(Message::RequestDeleteHistoryItem(delete_path))
                        .into()
                };

                let item_row = row()
                    .spacing(16)
                    .align_y(cosmic::iced::Alignment::Center)
                    .push(preview)
                    .push(info)
                    .push(cosmic::widget::horizontal_space())
                    .push(apply_btn)
                    .push(delete_btn);

                let item_container = container(item_row)
                    .padding(12)
                    .class(cosmic::theme::Container::Card);

                history_column = history_column.push(item_container);
            }

            scrollable(history_column)
                .width(Length::Fill)
                .height(Length::Fill)
                .into()
        };

        let status = text::body(self.status_message.clone());

        let content = column()
            .spacing(16)
            .padding(20)
            .push(title_row)
            .push(widget::divider::horizontal::default())
            .push(history_content)
            .push(status);

        container(content)
            .width(Length::Fill)
            .height(Length::Fill)
            .into()
    }
}

/// Cleans up old wallpapers that exceed the keep_days limit.
///
/// Looks at all bing-*.jpg files in the wallpaper directory, parses their dates,
/// and removes any that are older than the configured keep_days setting.
///
/// # Arguments
/// * `wallpaper_dir` - Path to the wallpaper directory
/// * `keep_days` - Number of days to keep wallpapers (0 means keep forever)
///
/// # Returns
/// Number of files deleted
fn cleanup_old_wallpapers(wallpaper_dir: &str, keep_days: u32) -> usize {
    if keep_days == 0 {
        return 0; // 0 means keep forever
    }

    let dir = std::path::Path::new(wallpaper_dir);
    if !dir.exists() {
        return 0;
    }

    let cutoff_date = chrono::Local::now().date_naive() - chrono::Duration::days(keep_days as i64);
    let mut deleted = 0;

    if let Ok(entries) = std::fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            let filename = path.file_name()
                .and_then(|s| s.to_str())
                .unwrap_or("");

            // Only process bing wallpaper files
            if !filename.starts_with("bing-") || !filename.ends_with(".jpg") {
                continue;
            }

            // Extract date from filename (last 10 chars before .jpg should be YYYY-MM-DD)
            let name_without_ext = filename.strip_suffix(".jpg").unwrap_or(filename);
            if name_without_ext.len() < 10 {
                continue;
            }

            let date_str = &name_without_ext[name_without_ext.len() - 10..];
            if let Ok(file_date) = chrono::NaiveDate::parse_from_str(date_str, "%Y-%m-%d") {
                if file_date < cutoff_date {
                    if std::fs::remove_file(&path).is_ok() {
                        deleted += 1;
                    }
                }
            }
        }
    }

    deleted
}

/// Scans the wallpaper directory and returns a list of history items.
///
/// Looks for .jpg, .jpeg, and .png files in the specified directory.
/// Extracts date information from filenames matching the pattern "bing-YYYY-MM-DD.jpg".
///
/// # Arguments
/// * `wallpaper_dir` - Path to the directory containing wallpaper images
///
/// # Returns
/// Vector of `HistoryItem` sorted by date descending (newest first)
fn scan_history(wallpaper_dir: &str) -> Vec<HistoryItem> {
    let dir = std::path::Path::new(wallpaper_dir);
    if !dir.exists() {
        return Vec::new();
    }

    let mut items: Vec<HistoryItem> = std::fs::read_dir(dir)
        .ok()
        .into_iter()
        .flatten()
        .filter_map(|entry| entry.ok())
        .filter(|entry| {
            // Only include image files
            entry.path().extension()
                .map(|ext| ext == "jpg" || ext == "jpeg" || ext == "png")
                .unwrap_or(false)
        })
        .map(|entry| {
            let path = entry.path();
            let filename = path.file_name()
                .map(|s| s.to_string_lossy().to_string())
                .unwrap_or_default();

            // Extract date from filename pattern "bing-{market}-YYYY-MM-DD.jpg"
            // The date is always the last 10 characters before the extension (YYYY-MM-DD)
            let name_without_ext = filename
                .strip_suffix(".jpg")
                .or_else(|| filename.strip_suffix(".jpeg"))
                .or_else(|| filename.strip_suffix(".png"))
                .unwrap_or(&filename);

            let date = if name_without_ext.len() >= 10 {
                // Extract last 10 chars which should be YYYY-MM-DD
                let potential_date = &name_without_ext[name_without_ext.len() - 10..];
                // Verify it looks like a date (YYYY-MM-DD format)
                if potential_date.len() == 10
                    && potential_date.chars().nth(4) == Some('-')
                    && potential_date.chars().nth(7) == Some('-')
                {
                    potential_date.to_string()
                } else {
                    name_without_ext.to_string()
                }
            } else {
                name_without_ext.to_string()
            };

            HistoryItem { path, filename, date }
        })
        .collect();

    // Sort by date descending (newest first)
    items.sort_by(|a, b| b.date.cmp(&a.date));
    items
}

/// Queries the tray service for the status of the auto-update timer via D-Bus.
///
/// # Returns
/// - `TimerStatus::Installed` with next run time if timer is enabled
/// - `TimerStatus::NotInstalled` if timer is disabled
/// - `TimerStatus::Error` if D-Bus connection fails (tray not running)
async fn check_timer_status() -> TimerStatus {
    match WallpaperClient::connect().await {
        Ok(client) => {
            match client.get_timer_enabled().await {
                Ok(enabled) => {
                    if enabled {
                        // Get the next run time
                        let next_run = match client.get_timer_next_run().await {
                            Ok(time) if !time.is_empty() => time,
                            _ => "Scheduled".to_string(),
                        };
                        TimerStatus::Installed { next_run }
                    } else {
                        TimerStatus::NotInstalled
                    }
                }
                Err(e) => TimerStatus::Error(format!("D-Bus error: {}", e))
            }
        }
        Err(_) => {
            // Tray not running - check timer state file directly
            let state = crate::timer::TimerState::load();
            if state.enabled {
                TimerStatus::Installed { next_run: "Tray not running".to_string() }
            } else {
                TimerStatus::NotInstalled
            }
        }
    }
}

/// Enables the auto-update timer via D-Bus to the tray service.
///
/// The tray service manages an internal timer that:
/// - Runs daily at 8:00 AM
/// - Catches up on missed runs after boot (with 5-minute delay)
/// - Random delay up to 5 minutes to avoid API hammering
///
/// # Errors
/// Returns error if D-Bus connection fails (tray not running).
async fn install_timer() -> Result<(), String> {
    match WallpaperClient::connect().await {
        Ok(client) => {
            client.set_timer_enabled(true).await
                .map_err(|e| format!("Failed to enable timer: {}", e))
        }
        Err(_) => {
            // Tray not running - set state directly for next tray start
            let mut state = crate::timer::TimerState::load();
            state.enabled = true;
            state.save()?;
            Ok(())
        }
    }
}

/// Disables the auto-update timer via D-Bus to the tray service.
///
/// # Errors
/// Returns error if D-Bus connection fails (tray not running).
async fn uninstall_timer() -> Result<(), String> {
    match WallpaperClient::connect().await {
        Ok(client) => {
            client.set_timer_enabled(false).await
                .map_err(|e| format!("Failed to disable timer: {}", e))
        }
        Err(_) => {
            // Tray not running - set state directly
            let mut state = crate::timer::TimerState::load();
            state.enabled = false;
            state.save()?;
            Ok(())
        }
    }
}

/// Sets a wallpaper image in the COSMIC desktop environment.
///
/// This works by:
/// 1. Writing the COSMIC background configuration in RON format
/// 2. Restarting the cosmic-bg process to apply the change
///
/// ## Configuration File
/// The config is written to:
/// `~/.config/cosmic/com.system76.CosmicBackground/v1/all`
///
/// ## RON Format
/// COSMIC uses RON (Rusty Object Notation) for configuration. The wallpaper
/// config specifies:
/// - `output: "all"` - Apply to all monitors
/// - `source: Path(...)` - Path to the image file
/// - `scaling_mode: Zoom` - Fill the screen, cropping if necessary
/// - `filter_method: Lanczos` - High-quality image scaling
///
/// ## Process Management
/// The function kills cosmic-bg, waits briefly, then restarts it if needed.
/// This ensures the new wallpaper is applied immediately.
///
/// # Arguments
/// * `image_path` - Absolute path to the wallpaper image file
///
/// # Errors
/// Returns error if config directory cannot be determined, directory creation
/// fails, file write fails, or cosmic-bg cannot be started.
/// Run a host command, using flatpak-spawn when in Flatpak sandbox
async fn run_host_command(cmd: &str, args: &[&str]) -> std::io::Result<std::process::Output> {
    if is_flatpak() {
        let mut spawn_args = vec!["--host", cmd];
        spawn_args.extend(args);
        tokio::process::Command::new("flatpak-spawn")
            .args(&spawn_args)
            .output()
            .await
    } else {
        tokio::process::Command::new(cmd)
            .args(args)
            .output()
            .await
    }
}

/// Spawn a host command in background, using flatpak-spawn when in Flatpak sandbox
async fn spawn_host_command(cmd: &str) -> std::io::Result<tokio::process::Child> {
    if is_flatpak() {
        tokio::process::Command::new("flatpak-spawn")
            .args(["--host", cmd])
            .spawn()
    } else {
        tokio::process::Command::new(cmd)
            .spawn()
    }
}

async fn apply_cosmic_wallpaper(image_path: &str) -> Result<(), String> {
    // Use host's config directory, not Flatpak's sandboxed one
    // In Flatpak, dirs::config_dir() returns ~/.var/app/APP_ID/config/
    // but COSMIC reads from ~/.config/
    let config_path = dirs::home_dir()
        .ok_or("Could not find home directory")?
        .join(".config/cosmic/com.system76.CosmicBackground/v1/all");

    // Build RON configuration for cosmic-bg
    let config_content = format!(
        r#"(
    output: "all",
    source: Path("{}"),
    filter_by_theme: false,
    rotation_frequency: 300,
    filter_method: Lanczos,
    scaling_mode: Zoom,
    sampling_method: Alphanumeric,
)"#,
        image_path
    );

    // Ensure config directory exists
    if let Some(parent) = config_path.parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("Failed to create config dir: {}", e))?;
    }

    // Write the configuration file
    std::fs::write(&config_path, config_content)
        .map_err(|e| format!("Failed to write config: {}", e))?;

    // Kill cosmic-bg to force config reload (use host command in Flatpak)
    let _ = run_host_command("pkill", &["-x", "cosmic-bg"]).await;

    // Wait for process to fully terminate
    tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

    // Always restart cosmic-bg to ensure the new wallpaper is loaded
    spawn_host_command("cosmic-bg").await
        .map_err(|e| format!("Failed to start cosmic-bg: {}", e))?;

    // Wait a moment and verify cosmic-bg is running
    tokio::time::sleep(tokio::time::Duration::from_millis(300)).await;

    let check = run_host_command("pgrep", &["-x", "cosmic-bg"]).await;

    match check {
        Ok(output) if output.status.success() => Ok(()),
        _ => Err("cosmic-bg failed to start - wallpaper may not have been applied".to_string())
    }
}

/// Public wrapper for headless wallpaper application.
///
/// Used by the CLI `--fetch` mode and internal timer.
pub async fn apply_wallpaper_headless(image_path: &str) -> Result<(), String> {
    apply_cosmic_wallpaper(image_path).await
}
