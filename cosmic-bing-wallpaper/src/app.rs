//! # COSMIC Application Module
//!
//! Implements the main application using the libcosmic toolkit, following the
//! Model-View-Update (MVU) architecture pattern.
//!
//! ## Architecture Overview
//!
//! The MVU pattern separates the application into three distinct parts:
//!
//! - **Model** (`BingWallpaper` struct): Holds all application state including
//!   configuration, current image, UI state, and timer status.
//!
//! - **View** (`view_main`, `view_history`): Pure functions that render the UI
//!   based on the current model state. Views are rebuilt whenever state changes.
//!
//! - **Update** (`update` method): Handles incoming messages, updates the model,
//!   and returns commands (async tasks) to be executed.
//!
//! ## Message Flow
//!
//! 1. User interacts with UI (e.g., clicks "Fetch Today's Image")
//! 2. UI generates a `Message` (e.g., `Message::FetchToday`)
//! 3. `update()` handles the message, updates state, returns async Task
//! 4. Task executes (API call, file download, etc.)
//! 5. Task completion generates another Message with the result
//! 6. `update()` handles the result message, updates state
//! 7. View re-renders with new state
//!
//! ## COSMIC Desktop Integration
//!
//! This app integrates with COSMIC by:
//! - Writing wallpaper config to `~/.config/cosmic/com.system76.CosmicBackground/v1/all`
//! - Using RON (Rusty Object Notation) format expected by cosmic-bg
//! - Restarting cosmic-bg process to apply changes
//! - Managing systemd user timers for automatic updates

use chrono;
use cosmic::app::Core;
use cosmic::iced::{Length, ContentFit};
use cosmic::widget::{self, button, column, container, row, text, dropdown, scrollable};
use cosmic::{Action, Application, Element, Task};
use std::path::PathBuf;

use crate::bing::{BingImage, fetch_bing_image_info, download_image};
use crate::config::{Config, MARKETS};

/// Unique application identifier for COSMIC.
/// Used for window identification and desktop integration.
pub const APP_ID: &str = "io.github.cosmic-bing-wallpaper";

/// Main application state struct.
///
/// Contains all mutable state for the application including configuration,
/// UI state, and cached data. This is the "Model" in MVU architecture.
pub struct BingWallpaper {
    /// COSMIC core state (window management, theming, etc.)
    core: Core,
    /// User configuration (market, wallpaper directory, etc.)
    config: Config,
    /// Metadata for the currently fetched Bing image
    current_image: Option<BingImage>,
    /// Local filesystem path to the downloaded image
    image_path: Option<String>,
    /// Status message displayed to the user (e.g., "Downloading...", "Error: ...")
    status_message: String,
    /// True when an async operation is in progress (disables buttons)
    is_loading: bool,
    /// List of previously downloaded wallpapers
    history: Vec<HistoryItem>,
    /// Index of selected market in the dropdown (maps to MARKETS array)
    selected_market_idx: usize,
    /// Current view (Main or History)
    view_mode: ViewMode,
    /// Pre-computed market names for dropdown (avoids lifetime issues in view)
    market_names: Vec<String>,
    /// Current status of the systemd auto-update timer
    timer_status: TimerStatus,
    /// Path of wallpaper pending deletion (for confirmation)
    pending_delete: Option<PathBuf>,
}

/// Represents a wallpaper in the download history.
///
/// Created by scanning the wallpaper directory for image files.
#[derive(Debug, Clone)]
pub struct HistoryItem {
    /// Full filesystem path to the image
    pub path: PathBuf,
    /// Filename only (e.g., "bing-2026-01-15.jpg")
    pub filename: String,
    /// Extracted date from filename for display (e.g., "2026-01-15")
    pub date: String,
}

/// Enum representing the current view/screen of the application.
#[derive(Debug, Clone, Default, PartialEq)]
pub enum ViewMode {
    /// Main view showing today's image and controls
    #[default]
    Main,
    /// History browser showing all downloaded wallpapers
    History,
}

/// Status of the systemd user timer for automatic updates.
///
/// Checked asynchronously on app startup and after install/uninstall operations.
#[derive(Debug, Clone, Default)]
pub enum TimerStatus {
    /// Timer status is being queried
    #[default]
    Checking,
    /// Timer is not installed (user can install it)
    NotInstalled,
    /// Timer is active with the next scheduled run time
    Installed {
        /// Human-readable next run time
        next_run: String
    },
    /// Error occurred while checking timer status
    Error(String),
}

/// All possible messages/events the application can receive.
///
/// Messages are the "Update" triggers in MVU architecture. They can be
/// generated by user interaction, async task completion, or system events.
#[derive(Debug, Clone)]
pub enum Message {
    // === Image Fetching ===
    /// User clicked "Fetch Today's Image" - starts the fetch chain
    FetchToday,
    /// API call completed - contains image metadata or error
    FetchedImageInfo(Result<BingImage, String>),
    /// Image download completed - contains file path or error
    DownloadedImage(Result<String, String>),

    // === Wallpaper Application ===
    /// User clicked "Apply as Wallpaper" for today's image
    ApplyWallpaper,
    /// User clicked "Apply" on a history item
    ApplyHistoryWallpaper(PathBuf),
    /// Wallpaper application completed
    AppliedWallpaper(Result<(), String>),

    // === UI Navigation ===
    /// Open wallpaper directory in file manager
    OpenWallpaperFolder,
    /// User selected a different market from dropdown
    MarketSelected(usize),
    /// Switch to history view
    ShowHistory,
    /// Switch back to main view
    ShowMain,
    /// Rescan wallpaper directory for history items
    RefreshHistory,
    /// Request to delete a wallpaper (shows confirmation)
    RequestDeleteHistoryItem(PathBuf),
    /// Confirm deletion of pending wallpaper
    ConfirmDeleteHistoryItem,
    /// Cancel pending deletion
    CancelDeleteHistoryItem,

    // === Timer Management ===
    /// Query systemd for timer status
    CheckTimerStatus,
    /// Timer status query completed
    TimerStatusChecked(TimerStatus),
    /// User clicked "Install Auto-Update Timer"
    InstallTimer,
    /// Timer installation completed
    TimerInstalled(Result<(), String>),
    /// User clicked "Remove Timer"
    UninstallTimer,
    /// Timer removal completed
    TimerUninstalled(Result<(), String>),
}

/// Implementation of the COSMIC Application trait.
///
/// This is where the MVU architecture connects to the COSMIC framework.
/// The trait requires defining the executor, flags, message type, and
/// implementing core(), core_mut(), init(), view(), and update().
impl Application for BingWallpaper {
    /// Async executor for running Tasks (uses tokio under the hood)
    type Executor = cosmic::executor::Default;
    /// Initialization flags (unused, unit type)
    type Flags = ();
    /// Message type for the application
    type Message = Message;

    /// Application identifier for COSMIC
    const APP_ID: &'static str = APP_ID;

    fn core(&self) -> &Core {
        &self.core
    }

    fn core_mut(&mut self) -> &mut Core {
        &mut self.core
    }

    /// Initializes the application state and triggers startup tasks.
    ///
    /// Called once when the application starts. Sets up:
    /// - Configuration loaded from disk (or defaults)
    /// - Empty image state
    /// - Wallpaper history scanned from disk
    /// - Market dropdown options
    ///
    /// Automatically triggers two startup actions:
    /// 1. Fetch today's Bing image
    /// 2. Check systemd timer status
    fn init(core: Core, _flags: Self::Flags) -> (Self, Task<Action<Self::Message>>) {
        let config = Config::load();

        // Find the index of the configured market in MARKETS array
        let selected_market_idx = MARKETS
            .iter()
            .position(|m| m.code == config.market)
            .unwrap_or(0);

        // Scan for existing wallpapers
        let history = scan_history(&config.wallpaper_dir);

        // Pre-compute market names to avoid lifetime issues in view()
        let market_names: Vec<String> = MARKETS.iter().map(|m| m.name.to_string()).collect();

        let app = Self {
            core,
            config,
            current_image: None,
            image_path: None,
            status_message: "Ready".to_string(),
            is_loading: false,
            history,
            selected_market_idx,
            view_mode: ViewMode::Main,
            market_names,
            timer_status: TimerStatus::Checking,
            pending_delete: None,
        };

        // Trigger startup actions: optionally fetch today's image and check timer status
        let timer_task = Task::perform(async {}, |_| Action::App(Message::CheckTimerStatus));

        if app.config.fetch_on_startup {
            let fetch_task = Task::perform(async {}, |_| Action::App(Message::FetchToday));
            (app, Task::batch([fetch_task, timer_task]))
        } else {
            (app, timer_task)
        }
    }

    fn header_start(&self) -> Vec<Element<'_, Self::Message>> {
        vec![]
    }

    /// Renders the UI based on current state.
    ///
    /// Delegates to `view_main()` or `view_history()` based on the current
    /// `view_mode`. This is the "View" in MVU architecture.
    fn view(&self) -> Element<'_, Self::Message> {
        match self.view_mode {
            ViewMode::Main => self.view_main(),
            ViewMode::History => self.view_history(),
        }
    }

    /// Handles incoming messages and returns tasks to execute.
    ///
    /// This is the "Update" in MVU architecture. Each message type has a
    /// corresponding handler that updates state and optionally returns
    /// async tasks for operations like API calls or file I/O.
    fn update(&mut self, message: Self::Message) -> Task<Action<Self::Message>> {
        match message {
            Message::FetchToday => {
                self.status_message = "Fetching image info...".to_string();
                self.is_loading = true;
                let market = self.config.market.clone();

                Task::perform(
                    async move { fetch_bing_image_info(&market).await },
                    |result| Action::App(Message::FetchedImageInfo(result)),
                )
            }

            Message::FetchedImageInfo(result) => {
                match result {
                    Ok(image) => {
                        self.current_image = Some(image.clone());
                        self.status_message = "Downloading image...".to_string();
                        let dir = self.config.wallpaper_dir.clone();
                        let market = self.config.market.clone();

                        Task::perform(
                            async move { download_image(&image, &dir, &market).await },
                            |result| Action::App(Message::DownloadedImage(result)),
                        )
                    }
                    Err(e) => {
                        self.status_message = format!("Error: {}", e);
                        self.is_loading = false;
                        Task::none()
                    }
                }
            }

            Message::DownloadedImage(result) => {
                self.is_loading = false;
                match result {
                    Ok(path) => {
                        self.image_path = Some(path);

                        // Clean up old wallpapers based on keep_days setting
                        let deleted = cleanup_old_wallpapers(&self.config.wallpaper_dir, self.config.keep_days);
                        if deleted > 0 {
                            self.status_message = format!(
                                "Image downloaded! ({} old wallpaper{} cleaned up). Click 'Apply' to set as wallpaper.",
                                deleted,
                                if deleted == 1 { "" } else { "s" }
                            );
                        } else {
                            self.status_message = "Image downloaded! Click 'Apply' to set as wallpaper.".to_string();
                        }

                        self.history = scan_history(&self.config.wallpaper_dir);
                    }
                    Err(e) => {
                        self.status_message = format!("Error: {}", e);
                    }
                }
                Task::none()
            }

            Message::ApplyWallpaper => {
                if let Some(path) = &self.image_path {
                    self.apply_wallpaper_from_path(path.clone())
                } else {
                    Task::none()
                }
            }

            Message::ApplyHistoryWallpaper(path) => {
                self.apply_wallpaper_from_path(path.to_string_lossy().to_string())
            }

            Message::AppliedWallpaper(result) => {
                self.is_loading = false;
                match result {
                    Ok(()) => {
                        self.status_message = "Wallpaper applied!".to_string();
                    }
                    Err(e) => {
                        self.status_message = format!("Error: {}", e);
                    }
                }
                Task::none()
            }

            Message::OpenWallpaperFolder => {
                let _ = open::that(&self.config.wallpaper_dir);
                Task::none()
            }

            Message::MarketSelected(idx) => {
                if idx < MARKETS.len() {
                    self.selected_market_idx = idx;
                    self.config.market = MARKETS[idx].code.to_string();
                    let _ = self.config.save();
                }
                Task::none()
            }

            Message::ShowHistory => {
                self.view_mode = ViewMode::History;
                self.history = scan_history(&self.config.wallpaper_dir);
                Task::none()
            }

            Message::ShowMain => {
                self.view_mode = ViewMode::Main;
                Task::none()
            }

            Message::RefreshHistory => {
                self.history = scan_history(&self.config.wallpaper_dir);
                Task::none()
            }

            Message::RequestDeleteHistoryItem(path) => {
                let filename = path.file_name()
                    .and_then(|s| s.to_str())
                    .unwrap_or("this image")
                    .to_string();
                self.pending_delete = Some(path);
                self.status_message = format!("Delete {}? Click 'Confirm' to delete or 'Cancel' to keep.", filename);
                Task::none()
            }

            Message::ConfirmDeleteHistoryItem => {
                if let Some(path) = self.pending_delete.take() {
                    if let Err(e) = std::fs::remove_file(&path) {
                        self.status_message = format!("Failed to delete: {}", e);
                    } else {
                        self.history = scan_history(&self.config.wallpaper_dir);
                        self.status_message = "Image deleted".to_string();
                    }
                }
                Task::none()
            }

            Message::CancelDeleteHistoryItem => {
                self.pending_delete = None;
                self.status_message = "Delete cancelled".to_string();
                Task::none()
            }

            Message::CheckTimerStatus => {
                Task::perform(
                    async { check_timer_status().await },
                    |status| Action::App(Message::TimerStatusChecked(status)),
                )
            }

            Message::TimerStatusChecked(status) => {
                self.timer_status = status;
                Task::none()
            }

            Message::InstallTimer => {
                self.status_message = "Installing systemd timer...".to_string();
                Task::perform(
                    async { install_timer().await },
                    |result| Action::App(Message::TimerInstalled(result)),
                )
            }

            Message::TimerInstalled(result) => {
                match result {
                    Ok(()) => {
                        self.status_message = "Timer installed successfully!".to_string();
                    }
                    Err(e) => {
                        self.status_message = format!("Failed to install timer: {}", e);
                    }
                }
                // Refresh timer status
                Task::perform(
                    async { check_timer_status().await },
                    |status| Action::App(Message::TimerStatusChecked(status)),
                )
            }

            Message::UninstallTimer => {
                self.status_message = "Uninstalling systemd timer...".to_string();
                Task::perform(
                    async { uninstall_timer().await },
                    |result| Action::App(Message::TimerUninstalled(result)),
                )
            }

            Message::TimerUninstalled(result) => {
                match result {
                    Ok(()) => {
                        self.status_message = "Timer uninstalled.".to_string();
                    }
                    Err(e) => {
                        self.status_message = format!("Failed to uninstall timer: {}", e);
                    }
                }
                Task::perform(
                    async { check_timer_status().await },
                    |status| Action::App(Message::TimerStatusChecked(status)),
                )
            }
        }
    }
}

impl BingWallpaper {
    fn apply_wallpaper_from_path(&mut self, path: String) -> Task<Action<Message>> {
        self.status_message = "Applying wallpaper...".to_string();
        self.is_loading = true;

        Task::perform(
            async move { apply_cosmic_wallpaper(&path).await },
            |result| Action::App(Message::AppliedWallpaper(result)),
        )
    }

    fn view_main(&self) -> Element<'_, Message> {
        let title = container(text::title1("Bing Daily Wallpaper"))
            .width(Length::Fill)
            .center_x(Length::Fill);

        // Image preview - center the image using a column with center alignment
        let preview: Element<_> = if let Some(path) = &self.image_path {
            column()
                .width(Length::Fill)
                .align_x(cosmic::iced::Alignment::Center)
                .push(
                    widget::image(path)
                        .content_fit(ContentFit::Contain)
                        .height(Length::Fixed(300.0))
                )
                .into()
        } else {
            container(
                text::body("No image loaded")
            )
            .padding(40)
            .width(Length::Fill)
            .center_x(Length::Fill)
            .class(cosmic::theme::Container::Card)
            .into()
        };

        // Image info - centered
        let image_info: Element<_> = if let Some(img) = &self.current_image {
            column()
                .spacing(4)
                .align_x(cosmic::iced::Alignment::Center)
                .width(Length::Fill)
                .push(text::heading(img.title.clone()))
                .push(text::caption(img.copyright.clone()))
                .into()
        } else {
            container(text::body("Fetch an image to see details"))
                .width(Length::Fill)
                .center_x(Length::Fill)
                .into()
        };

        // Status - centered
        let status = container(text::body(self.status_message.clone()))
            .width(Length::Fill)
            .center_x(Length::Fill);

        // Region selector - centered
        let region_selector = container(
            row()
                .spacing(12)
                .align_y(cosmic::iced::Alignment::Center)
                .push(text::body("Region:"))
                .push(
                    container(
                        dropdown(&self.market_names, Some(self.selected_market_idx), Message::MarketSelected)
                            .width(Length::Fixed(180.0))
                    )
                    .padding(4)
                    .class(cosmic::theme::Container::Card)
                )
        )
        .width(Length::Fill)
        .center_x(Length::Fill);

        // Action buttons - centered
        let fetch_btn = button::standard("Fetch Today's Image")
            .on_press_maybe(if self.is_loading { None } else { Some(Message::FetchToday) });

        let apply_btn = button::suggested("Apply as Wallpaper")
            .on_press_maybe(
                if self.is_loading || self.image_path.is_none() {
                    None
                } else {
                    Some(Message::ApplyWallpaper)
                }
            );

        let history_btn = button::standard("Downloaded")
            .on_press(Message::ShowHistory);

        let buttons = container(
            row()
                .spacing(12)
                .push(fetch_btn)
                .push(apply_btn)
                .push(history_btn)
        )
        .width(Length::Fill)
        .center_x(Length::Fill);

        // Auto-update section with timer status
        let timer_info = match &self.timer_status {
            TimerStatus::Checking => text::caption("Checking timer status...".to_string()),
            TimerStatus::NotInstalled => text::caption("Timer not installed".to_string()),
            TimerStatus::Installed { next_run } => text::caption(format!("Next run: {}", next_run)),
            TimerStatus::Error(e) => text::caption(format!("Timer error: {}", e)),
        };

        let timer_button: Element<_> = match &self.timer_status {
            TimerStatus::NotInstalled => {
                button::suggested("Install Auto-Update Timer")
                    .on_press(Message::InstallTimer)
                    .into()
            }
            TimerStatus::Installed { .. } => {
                button::destructive("Remove Timer")
                    .on_press(Message::UninstallTimer)
                    .into()
            }
            _ => {
                button::standard("Check Status")
                    .on_press(Message::CheckTimerStatus)
                    .into()
            }
        };

        let auto_update_section = container(
            column()
                .spacing(8)
                .align_x(cosmic::iced::Alignment::Center)
                .push(text::body("Daily Auto-Update"))
                .push(timer_info)
                .push(timer_button)
        )
        .width(Length::Fill)
        .center_x(Length::Fill);

        // Main content
        let content = column()
            .spacing(16)
            .padding(20)
            .max_width(800)
            .push(title)
            .push(preview)
            .push(image_info)
            .push(status)
            .push(region_selector)
            .push(buttons)
            .push(widget::divider::horizontal::default())
            .push(auto_update_section);

        container(content)
            .width(Length::Fill)
            .height(Length::Fill)
            .center_x(Length::Fill)
            .into()
    }

    fn view_history(&self) -> Element<'_, Message> {
        let title_row = row()
            .spacing(12)
            .align_y(cosmic::iced::Alignment::Center)
            .push(
                button::icon(widget::icon::from_name("go-previous-symbolic"))
                    .on_press(Message::ShowMain)
            )
            .push(text::title1("Downloaded Wallpapers"))
            .push(cosmic::widget::horizontal_space())
            .push(
                button::standard("Open Folder")
                    .on_press(Message::OpenWallpaperFolder)
            )
            .push(
                button::icon(widget::icon::from_name("view-refresh-symbolic"))
                    .on_press(Message::RefreshHistory)
            );

        let history_content: Element<_> = if self.history.is_empty() {
            container(text::body("No wallpapers downloaded yet"))
                .padding(40)
                .center_x(Length::Fill)
                .into()
        } else {
            let mut history_column = column().spacing(12).padding(10);

            for item in &self.history {
                let item_path = item.path.clone();
                let delete_path = item.path.clone();

                let preview = widget::image(item.path.to_string_lossy().to_string())
                    .content_fit(ContentFit::Cover)
                    .width(Length::Fixed(160.0))
                    .height(Length::Fixed(90.0));

                let info = column()
                    .spacing(4)
                    .push(text::body(item.date.clone()))
                    .push(text::caption(item.filename.clone()));

                let apply_btn = button::suggested("Apply")
                    .on_press(Message::ApplyHistoryWallpaper(item_path));

                // Show confirm/cancel if this item is pending deletion, otherwise show delete button
                let is_pending = self.pending_delete.as_ref() == Some(&item.path);
                let delete_btn: Element<_> = if is_pending {
                    row()
                        .spacing(8)
                        .push(button::destructive("Confirm").on_press(Message::ConfirmDeleteHistoryItem))
                        .push(button::standard("Cancel").on_press(Message::CancelDeleteHistoryItem))
                        .into()
                } else {
                    button::destructive("Delete")
                        .on_press(Message::RequestDeleteHistoryItem(delete_path))
                        .into()
                };

                let item_row = row()
                    .spacing(16)
                    .align_y(cosmic::iced::Alignment::Center)
                    .push(preview)
                    .push(info)
                    .push(cosmic::widget::horizontal_space())
                    .push(apply_btn)
                    .push(delete_btn);

                let item_container = container(item_row)
                    .padding(12)
                    .class(cosmic::theme::Container::Card);

                history_column = history_column.push(item_container);
            }

            scrollable(history_column)
                .width(Length::Fill)
                .height(Length::Fill)
                .into()
        };

        let status = text::body(self.status_message.clone());

        let content = column()
            .spacing(16)
            .padding(20)
            .push(title_row)
            .push(widget::divider::horizontal::default())
            .push(history_content)
            .push(status);

        container(content)
            .width(Length::Fill)
            .height(Length::Fill)
            .into()
    }
}

/// Cleans up old wallpapers that exceed the keep_days limit.
///
/// Looks at all bing-*.jpg files in the wallpaper directory, parses their dates,
/// and removes any that are older than the configured keep_days setting.
///
/// # Arguments
/// * `wallpaper_dir` - Path to the wallpaper directory
/// * `keep_days` - Number of days to keep wallpapers (0 means keep forever)
///
/// # Returns
/// Number of files deleted
fn cleanup_old_wallpapers(wallpaper_dir: &str, keep_days: u32) -> usize {
    if keep_days == 0 {
        return 0; // 0 means keep forever
    }

    let dir = std::path::Path::new(wallpaper_dir);
    if !dir.exists() {
        return 0;
    }

    let cutoff_date = chrono::Local::now().date_naive() - chrono::Duration::days(keep_days as i64);
    let mut deleted = 0;

    if let Ok(entries) = std::fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            let filename = path.file_name()
                .and_then(|s| s.to_str())
                .unwrap_or("");

            // Only process bing wallpaper files
            if !filename.starts_with("bing-") || !filename.ends_with(".jpg") {
                continue;
            }

            // Extract date from filename (last 10 chars before .jpg should be YYYY-MM-DD)
            let name_without_ext = filename.strip_suffix(".jpg").unwrap_or(filename);
            if name_without_ext.len() < 10 {
                continue;
            }

            let date_str = &name_without_ext[name_without_ext.len() - 10..];
            if let Ok(file_date) = chrono::NaiveDate::parse_from_str(date_str, "%Y-%m-%d") {
                if file_date < cutoff_date {
                    if std::fs::remove_file(&path).is_ok() {
                        deleted += 1;
                    }
                }
            }
        }
    }

    deleted
}

/// Scans the wallpaper directory and returns a list of history items.
///
/// Looks for .jpg, .jpeg, and .png files in the specified directory.
/// Extracts date information from filenames matching the pattern "bing-YYYY-MM-DD.jpg".
///
/// # Arguments
/// * `wallpaper_dir` - Path to the directory containing wallpaper images
///
/// # Returns
/// Vector of `HistoryItem` sorted by date descending (newest first)
fn scan_history(wallpaper_dir: &str) -> Vec<HistoryItem> {
    let dir = std::path::Path::new(wallpaper_dir);
    if !dir.exists() {
        return Vec::new();
    }

    let mut items: Vec<HistoryItem> = std::fs::read_dir(dir)
        .ok()
        .into_iter()
        .flatten()
        .filter_map(|entry| entry.ok())
        .filter(|entry| {
            // Only include image files
            entry.path().extension()
                .map(|ext| ext == "jpg" || ext == "jpeg" || ext == "png")
                .unwrap_or(false)
        })
        .map(|entry| {
            let path = entry.path();
            let filename = path.file_name()
                .map(|s| s.to_string_lossy().to_string())
                .unwrap_or_default();

            // Extract date from filename pattern "bing-{market}-YYYY-MM-DD.jpg"
            // The date is always the last 10 characters before the extension (YYYY-MM-DD)
            let name_without_ext = filename
                .strip_suffix(".jpg")
                .or_else(|| filename.strip_suffix(".jpeg"))
                .or_else(|| filename.strip_suffix(".png"))
                .unwrap_or(&filename);

            let date = if name_without_ext.len() >= 10 {
                // Extract last 10 chars which should be YYYY-MM-DD
                let potential_date = &name_without_ext[name_without_ext.len() - 10..];
                // Verify it looks like a date (YYYY-MM-DD format)
                if potential_date.len() == 10
                    && potential_date.chars().nth(4) == Some('-')
                    && potential_date.chars().nth(7) == Some('-')
                {
                    potential_date.to_string()
                } else {
                    name_without_ext.to_string()
                }
            } else {
                name_without_ext.to_string()
            };

            HistoryItem { path, filename, date }
        })
        .collect();

    // Sort by date descending (newest first)
    items.sort_by(|a, b| b.date.cmp(&a.date));
    items
}

/// Queries systemd for the status of the auto-update timer.
///
/// Uses `systemctl --user` commands to:
/// 1. Check if the timer is active
/// 2. If active, get the next scheduled run time
///
/// # Returns
/// - `TimerStatus::Installed` with next run time if timer is active
/// - `TimerStatus::NotInstalled` if timer is not active
/// - `TimerStatus::Error` if systemctl command fails
async fn check_timer_status() -> TimerStatus {
    // Check if timer is active
    let output = tokio::process::Command::new("systemctl")
        .args(["--user", "is-active", "cosmic-bing-wallpaper.timer"])
        .output()
        .await;

    match output {
        Ok(out) => {
            let status = String::from_utf8_lossy(&out.stdout).trim().to_string();
            if status == "active" {
                // Timer is active - get the next scheduled run time
                // Use systemctl show with multiple properties to get reliable data
                let next_output = tokio::process::Command::new("systemctl")
                    .args(["--user", "show", "cosmic-bing-wallpaper.timer",
                           "--property=NextElapseUSecRealtime"])
                    .output()
                    .await;

                let next_run = match next_output {
                    Ok(out) => {
                        let raw = String::from_utf8_lossy(&out.stdout).trim().to_string();
                        // Parse the property output (format: NextElapseUSecRealtime=TIMESTAMP)
                        let timestamp = raw.strip_prefix("NextElapseUSecRealtime=")
                            .unwrap_or(&raw);

                        if timestamp.is_empty() || timestamp == "n/a" {
                            "Scheduled (time unknown)".to_string()
                        } else {
                            // The timestamp is in microseconds since epoch or a formatted string
                            // Try to parse and format it nicely
                            if let Ok(usecs) = timestamp.parse::<u64>() {
                                // Convert microseconds to seconds and format
                                let secs = usecs / 1_000_000;
                                if let Some(dt) = chrono::DateTime::from_timestamp(secs as i64, 0) {
                                    let local: chrono::DateTime<chrono::Local> = dt.into();
                                    local.format("%a %b %d %H:%M").to_string()
                                } else {
                                    "Scheduled".to_string()
                                }
                            } else {
                                // Already a formatted string, use as-is
                                timestamp.to_string()
                            }
                        }
                    }
                    Err(_) => "Scheduled (time unknown)".to_string()
                };
                TimerStatus::Installed { next_run }
            } else {
                TimerStatus::NotInstalled
            }
        }
        Err(e) => TimerStatus::Error(e.to_string())
    }
}

/// Installs the systemd user timer for automatic daily wallpaper updates.
///
/// Creates two systemd unit files in `~/.config/systemd/user/`:
/// - `cosmic-bing-wallpaper.service`: Runs the binary or script
/// - `cosmic-bing-wallpaper.timer`: Schedules daily execution at 8:00 AM
///
/// ## Executable Detection
/// Looks for the executable in this order:
/// 1. Installed binary at `~/.local/bin/cosmic-bing-wallpaper`
/// 2. System binary at `/usr/local/bin/cosmic-bing-wallpaper`
/// 3. Shell script at `~/.local/share/cosmic-bing-wallpaper/bing-wallpaper.sh`
///
/// ## AppImage Support
/// When running from an AppImage, the bundled shell script is copied to
/// `~/.local/share/cosmic-bing-wallpaper/` for persistent use.
///
/// ## Timer Configuration
/// - Runs daily at 8:00 AM
/// - Also runs 5 minutes after boot (catches up if missed)
/// - Random delay up to 5 minutes to avoid thundering herd
/// - Persistent: runs immediately if a scheduled time was missed
///
/// # Errors
/// Returns error if no executable found, or if file operations fail.
async fn install_timer() -> Result<(), String> {
    let home = dirs::home_dir().ok_or("Could not find home directory")?;
    let systemd_dir = home.join(".config/systemd/user");

    // Ensure systemd user directory exists
    std::fs::create_dir_all(&systemd_dir)
        .map_err(|e| format!("Failed to create systemd directory: {}", e))?;

    // Look for the executable in standard locations
    let local_bin = home.join(".local/bin/cosmic-bing-wallpaper");
    let system_bin = std::path::Path::new("/usr/local/bin/cosmic-bing-wallpaper");
    let local_script = home.join(".local/share/cosmic-bing-wallpaper/bing-wallpaper.sh");

    let exec_path = if local_bin.exists() {
        // Prefer installed binary in user's local bin
        format!("{} --fetch-and-apply", local_bin.display())
    } else if system_bin.exists() {
        // Fall back to system-wide installation
        format!("{} --fetch-and-apply", system_bin.display())
    } else {
        // Fall back to shell script
        // If running from AppImage, copy the bundled script first
        if let Ok(appimage_script) = std::env::var("BING_WALLPAPER_SCRIPT") {
            if let Some(parent) = local_script.parent() {
                std::fs::create_dir_all(parent)
                    .map_err(|e| format!("Failed to create script directory: {}", e))?;
            }
            std::fs::copy(&appimage_script, &local_script)
                .map_err(|e| format!("Failed to copy script: {}", e))?;
            // Make it executable
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                std::fs::set_permissions(&local_script, std::fs::Permissions::from_mode(0o755))
                    .map_err(|e| format!("Failed to set script permissions: {}", e))?;
            }
        }

        if local_script.exists() {
            local_script.to_string_lossy().to_string()
        } else {
            return Err("No executable found. Please install the app first using ./install.sh".to_string());
        }
    };

    // Write service file
    // Note: We don't hardcode DISPLAY or WAYLAND_DISPLAY because:
    // 1. COSMIC is Wayland-native and inherits the session environment
    // 2. The service runs under the user's graphical session via default.target
    // 3. Hardcoded values like :0 or wayland-1 may not match the actual session
    let service_content = format!(r#"[Unit]
Description=Fetch and set Bing daily wallpaper for COSMIC desktop
After=network-online.target graphical-session.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart={}
Environment=HOME=%h
Environment=XDG_RUNTIME_DIR=/run/user/%U

[Install]
WantedBy=default.target
"#, exec_path);

    std::fs::write(systemd_dir.join("cosmic-bing-wallpaper.service"), &service_content)
        .map_err(|e| format!("Failed to write service file: {}", e))?;

    // Write timer file
    let timer_content = r#"[Unit]
Description=Daily Bing wallpaper update timer

[Timer]
OnCalendar=*-*-* 08:00:00
OnBootSec=5min
RandomizedDelaySec=300
Persistent=true

[Install]
WantedBy=timers.target
"#;

    std::fs::write(systemd_dir.join("cosmic-bing-wallpaper.timer"), timer_content)
        .map_err(|e| format!("Failed to write timer file: {}", e))?;

    // Reload and enable
    let reload = tokio::process::Command::new("systemctl")
        .args(["--user", "daemon-reload"])
        .output()
        .await
        .map_err(|e| format!("Failed to reload systemd: {}", e))?;

    if !reload.status.success() {
        return Err("Failed to reload systemd daemon".to_string());
    }

    let enable = tokio::process::Command::new("systemctl")
        .args(["--user", "enable", "--now", "cosmic-bing-wallpaper.timer"])
        .output()
        .await
        .map_err(|e| format!("Failed to enable timer: {}", e))?;

    if !enable.status.success() {
        return Err(format!("Failed to enable timer: {}", String::from_utf8_lossy(&enable.stderr)));
    }

    Ok(())
}

/// Removes the systemd user timer for automatic updates.
///
/// Disables and stops the timer, then removes the unit files from
/// `~/.config/systemd/user/`. Reloads the systemd daemon afterward.
///
/// # Errors
/// Returns error if systemctl disable command fails. File removal errors
/// are silently ignored (files may not exist).
async fn uninstall_timer() -> Result<(), String> {
    // Disable and stop the timer
    let output = tokio::process::Command::new("systemctl")
        .args(["--user", "disable", "--now", "cosmic-bing-wallpaper.timer"])
        .output()
        .await
        .map_err(|e| format!("Failed to disable timer: {}", e))?;

    if !output.status.success() {
        return Err(format!("Failed to disable timer: {}", String::from_utf8_lossy(&output.stderr)));
    }

    // Clean up unit files (errors ignored - files may not exist)
    let home = dirs::home_dir().ok_or("Could not find home directory")?;
    let systemd_dir = home.join(".config/systemd/user");

    let _ = std::fs::remove_file(systemd_dir.join("cosmic-bing-wallpaper.service"));
    let _ = std::fs::remove_file(systemd_dir.join("cosmic-bing-wallpaper.timer"));

    // Reload daemon to pick up the removal
    let _ = tokio::process::Command::new("systemctl")
        .args(["--user", "daemon-reload"])
        .output()
        .await;

    Ok(())
}

/// Sets a wallpaper image in the COSMIC desktop environment.
///
/// This works by:
/// 1. Writing the COSMIC background configuration in RON format
/// 2. Restarting the cosmic-bg process to apply the change
///
/// ## Configuration File
/// The config is written to:
/// `~/.config/cosmic/com.system76.CosmicBackground/v1/all`
///
/// ## RON Format
/// COSMIC uses RON (Rusty Object Notation) for configuration. The wallpaper
/// config specifies:
/// - `output: "all"` - Apply to all monitors
/// - `source: Path(...)` - Path to the image file
/// - `scaling_mode: Zoom` - Fill the screen, cropping if necessary
/// - `filter_method: Lanczos` - High-quality image scaling
///
/// ## Process Management
/// The function kills cosmic-bg, waits briefly, then restarts it if needed.
/// This ensures the new wallpaper is applied immediately.
///
/// # Arguments
/// * `image_path` - Absolute path to the wallpaper image file
///
/// # Errors
/// Returns error if config directory cannot be determined, directory creation
/// fails, file write fails, or cosmic-bg cannot be started.
async fn apply_cosmic_wallpaper(image_path: &str) -> Result<(), String> {
    // Determine config path for COSMIC background
    let config_path = dirs::config_dir()
        .ok_or("Could not find config directory")?
        .join("cosmic/com.system76.CosmicBackground/v1/all");

    // Build RON configuration for cosmic-bg
    let config_content = format!(
        r#"(
    output: "all",
    source: Path("{}"),
    filter_by_theme: false,
    rotation_frequency: 300,
    filter_method: Lanczos,
    scaling_mode: Zoom,
    sampling_method: Alphanumeric,
)"#,
        image_path
    );

    // Ensure config directory exists
    if let Some(parent) = config_path.parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("Failed to create config dir: {}", e))?;
    }

    // Write the configuration file
    std::fs::write(&config_path, config_content)
        .map_err(|e| format!("Failed to write config: {}", e))?;

    // Kill cosmic-bg to force config reload
    let _ = tokio::process::Command::new("pkill")
        .args(["-x", "cosmic-bg"])
        .output()
        .await;

    // Wait for process to fully terminate
    tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

    // Always restart cosmic-bg to ensure the new wallpaper is loaded
    tokio::process::Command::new("cosmic-bg")
        .spawn()
        .map_err(|e| format!("Failed to start cosmic-bg: {}", e))?;

    // Wait a moment and verify cosmic-bg is running
    tokio::time::sleep(tokio::time::Duration::from_millis(300)).await;

    let check = tokio::process::Command::new("pgrep")
        .args(["-x", "cosmic-bg"])
        .output()
        .await;

    match check {
        Ok(output) if output.status.success() => Ok(()),
        _ => Err("cosmic-bg failed to start - wallpaper may not have been applied".to_string())
    }
}

/// Public wrapper for headless wallpaper application.
///
/// Used by the CLI `--fetch-and-apply` mode for systemd timer integration.
pub async fn apply_wallpaper_headless(image_path: &str) -> Result<(), String> {
    apply_cosmic_wallpaper(image_path).await
}
